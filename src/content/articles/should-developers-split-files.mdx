---
title: "ファイルを分けるべきか?"
date: 2026-02-04
writer: "Uliboooo"
description: "モジュール化とファイルシステム上での分割"
tags: ["file-sys", "dev", "thoughts"]
publish: true
---

## ファイルが多い

プログラミング言語は割と多くのファイルを実行に要求します。特にコンパイル型の言語やシステム,web系の言語はインタープリターやスクリプト系の言語と比べ、再現性や保守性の観点から1つのコードを実行するのに複数のファイルを要求することが多いです。

例えば最近話題に上がることも多い? `moonbit`という言語も`moon`というmoonbitプロジェクトの管理cliが付随しますが、それで新規プロジェクトを生成すると以下のファイルが作成されます。


```bash
.
├── _build
├── AGENTS.md
├── cmd
│   └── main
│       ├── main.mbt
│       └── moon.pkg.json
├── LICENSE
├── moon.mod.json
├── moon.pkg.json
├── prac_moonbit.mbt
├── prac_moonbit_test.mbt
├── README.mbt.md
└── README.md -> README.mbt.md
```

多いです。まだ`1.0`ではないので変更があるかもしれませんが、それでも多く感じます。またwebも割とファイルが増えがちで、

## なぜファイルが増えるのか?

大概は意味的な分割をファイルシステム上で行うことで保守性や副次的な意味ではありますが、gitなどの管理を行いやすくする事が目的であると考えられます。Rustで言えばソースコードは`src/main.rs`などに、依存関係などは`Cargo.toml`に記述します。

```rust title="src/main.rs"
fn main() {
    println!("Hello, world!");
}
```

```toml title="cargo.toml"
[package]
name = "hello"
version = "0.1.0"
edition = "2024"

[dependencies]
clap = { version = "4.5.*", features = ["derive"] } # clapはRustのcli引数のパーサー

```
また、意味的にもファイルの分割はよく行われ、モジュールとしての表現としてファイルシステムを用いることもあるでしょう。

以下は私のcliの例です。正直ツールのサイズに対してモジュール化を過度にやりすぎた感はありますが、webなどでは割と多くの構成でファイル数が多いと感じます。

```bash title="自作のcliのモジュール構成"
./src
├── cli.rs
├── cli_helper.rs
├── commit_gen.rs
├── config.rs
├── diff_sum_gen.rs
├── get_input.rs
├── git.rs
├── helper.rs
├── llm.rs
├── main.rs
├── readme_gen.rs
└── which_sem.rs
```

https://github.com/Uliboooo/ghost_git_writer

### 1ファイルではダメなのか?

詳細は後述しますが、私はなるべくならファイルの数を増やしたくないのです。そこで以下のようなrust likeな言語`lust`を仮定します。

```rust title="lust/src/main.ls"
[pkg]
name = "hello"
ver = "0.1.0"

[deps]
clap = {ver = "4.5.*", feat = ["derive"]}

fn main () {
    print("Hello, world!");
}
```

依存関係も関数も1ファイルに記述できて便利ですね。

しかしこの構成には問題があります。

先ほどの例で出した`Rust`は、依存関係にある`clap`のバージョンが上がった際でも依存関係の記述と処理の記述はファイルレベルで分割されているため、`main.rs`を変更しません。依存関係の変更なのか実際の処理ロジックなどの変更なのかが差分のあるファイル名だけでは読み取れないという事です。

```toml title="cargo.toml"
[package]
name = "hello"
version = "0.1.0"
edition = "2024"

[dependencies]
# 4.5.* -> 4.6.*
clap = { version = "4.6.*", features = ["derive"] }
# minorの変更でもmain.rsを確認しとけとは思うけれども
```

つまり保守性やレビューなどの観点から意味的な分割とファイルシステム的な分割は密な関係であると言えます。

## ファイルの切り替えが面倒くさい

そもそもとしてエディタでファイルを切り替える際は何をするのか? 多くのユーザーに人気なVSCodeでは大概がサイドペインのファイルエクスプローラーや上部のタブを使うでしょう。その際はマウスかキーボードかを使って移動するわけです。中には`ctrl_ + p`を使ってファイルピッカー的な事をしてる人もいるかも知れません。私はneovimのtelescopeでファイルピッカーを用いて検索 > 開く をしています。

しかし安易にファイルを増やすと(先ほどの自作のように)とにかくファイルの移動が増えます。その時間が無駄に感じてしまいます。実際はlspなどのジャンプやsymbol検索などでそこそこの効率化は行えますが、非本質な時間が増えるようにも思えます。

## ファイルシステムからの脱却

そこで、ファイルシステムから脱却した、仮想的なバッファーに全てのコードを記述して、そこを意味的な分割記号を用いて意味を分け、エディターはそれをlspなどの**意味的な解釈**を行える機械(lspなど)とともに移動、編集すること言う世界があるのではと思う。

しかし最終的にはコンピューターが処理を行う以上はファイル分割がされた方が効率が上がりそうではあるし、人間もlspがないと認知負荷がすぐに超えるような環境はあまりいいとは言えないだろう。

理想としては上下左右に自由に記述できるバッファーと強力な折りたたみ機能で認知負荷を下げながら、ファイルシステムなどから解放された環境での開発が欲しい。
